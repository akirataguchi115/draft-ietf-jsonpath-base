<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.18 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2020"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft</spanx> (which needs to be fixed soon).</t>


    </note>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues can be directed at the github repository <spanx style="emph">insert
repo here</spanx> as well as (for the time when the more permanent home is
being decided) at the dispatch@ietf.org mailing list.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.  The purposes of the two syntaxes
are different. Pointer is for isolating a single location within a
document. Path is a query syntax that can also be used to pull multiple locations.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers, namely maps (JSON objects) and arrays, and
of atomic data, namely null, true, false, numbers, and text strings.
Also called a JSON value.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Member:">
  A key/value pair in a map (JSON Object).  (Not itself a JSON value.)</t>
  <t hangText="Element:">
  An item in an array.  (Also used with a distinct meaning in XML
context for XML elements.)</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of
powerful tools to analyse, transform and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</t>
</list></t>

<t>So what does such a tool look like for JSON?
When defining a JSONPath, how should expressions look?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is anonymous, JSONPath uses the abstract name <spanx style="verb">$</spanx> to
refer to the top level data item of the argument.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.
[1]
Where a JSONPath processor uses JSONPath expressions as output paths,
these will always be converted to normalized JSONPath expressions
which employ the more general <spanx style="emph">bracket–notation</spanx>.
[2]
Bracket notation is more general than dot notation and can serve as a
canonical form when a JSONPath processor uses JSONPath expressions as
output paths.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath was originally designed to employ an <spanx style="emph">underlying scripting
language</spanx> for computing expressions.  The present specification
defines a simple expression language that is independent from any
scripting language in use on the platform.</t>

<t>JSONPath can use expressions, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, as
an alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current item.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root element/item</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current element/item</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants (JSONPath borrows this syntax from E4X)</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard: All elements/items regardless of their names</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access: JSON data items do not have attributes</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator: XPath uses it to iterate over element collections and for predicates; native array indexing as in JavaScript here</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath (results in a combination of node sets); JSONPath allows alternate names or array indices as a set</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>expression engine</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">JSON object</spanx> or <spanx style="emph">array</spanx>
addressed by the previous path fragment. Array indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> use the expression mechanism to obtain
the number of items in an array, to test for the presence of a map
member, and to perform numeric comparisons of map member values with a
constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the prices of everything in the store</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1]</spanx></c>
      <c>the last book in order</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheaper than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all elements in XML document; all members of JSON data item</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types JSON object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = "$"               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type JSON object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type JSON object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = "." dot-child-name / ; .<dot-child-name>
            "." "*"             ; .*
dot-child-name = 1*(
                   "-" /         ; -
                   DIGIT /
                   ALPHA /
                   "_" /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any JSON object node.
It selects
no nodes from a node which is not a JSON object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any JSON object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = "[" ws union-elements ws "]" ; [...]
ws = *" "                             ; zero or more spaces
union-elements = union-element /
                 union-element ws "," ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        "'" *single-quoted "'"   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /         ; "    quotation mark  U+0022
              "/" /          ; /    solidus         U+002F
              "\" /          ; \    reverse solidus U+005C
              "b" /          ; b    backspace       U+0008
              "f" /          ; f    form feed       U+000C
              "n" /          ; n    line feed       U+000A
              "r" /          ; r    carriage return U+000D
              "t" /          ; t    tab             U+0009
              "u" 4HEXDIG )  ; uXXXX                U+XXXX


dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              "'" /          ; '    apostrophe      U+0027
              "/" /          ; /    solidus         U+002F
              "\" /          ; \    reverse solidus U+005C
              "b" /          ; b    backspace       U+0008
              "f" /          ; f    form feed       U+000C
              "n" /          ; n    line feed       U+000A
              "r" /          ; r    carriage return U+000D
              "t" /          ; t    tab             U+0009
              "u" 4HEXDIG )  ; uXXXX                U+XXXX

sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = "\"                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>"" %x22</c>
      <c>U+0022</c>
      <c>"" "'"</c>
      <c>U+0027</c>
      <c>"" "/"</c>
      <c>U+002F</c>
      <c>"" ""</c>
      <c>U+005C</c>
      <c>"" "b"</c>
      <c>U+0008</c>
      <c>"" "f"</c>
      <c>U+000C</c>
      <c>"" "n"</c>
      <c>U+000A</c>
      <c>"" "r"</c>
      <c>U+000D</c>
      <c>"" "t"</c>
      <c>U+0009</c>
      <c>"" uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any JSON object
node with the key as a name.
It selects no nodes from a node which is not a JSON object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
H4sIAIG5z18AA+1963Ibx5Lm/36KGtgnRNIACICiLMKibYqkLJ7VbURq7RlZ
cdAACkQfNbpxuhqiYEkT8w4z/2d/bOwj7APMeZN5ks0vs6q7utGQpTOedcTG
MhQi0V2XrLxnVlah0+kEJg+T6Z/COE30UOXZSgfRMuO/TD7o9Y56g2CaTpJw
Qa+nWTjLO0maLaLkOk+Tzp9NmizDfN6Jw1ybPJiE+VCZfBqkY5PGmp4N1a1b
wWo5Dd3fkzQxOjErfMJ0twKzGi8iY6I0yddLmuXi/OpBEIfJ9VDpJFhGw0Cp
PJ0U7fnTVC/zOT26jc9mvcj0zHgtTJrltUeTdLHQSW7sKvMoj2myP4ZvwstJ
Fi1z9XT8Zz3J1ZM0D3MCRu388fLpk131jNYXhONxpt9Qc3okDzIdDtXJ86vg
5rp8rH78IXh9I58DrHmoBr1BLwjCVT5Ps2HQUVmKafU0ytOMoIoSAuiHLs3q
kEoPBds/xOuk+jzNaK7//viGJm+ri2TSxUppnTpn1NIao3w9VD9GyWRO5NCY
INPXtBj3Pp3q4s9VkmfU+sV/o0/LOdOf3+hFGMVDdU3Td0taf3+Nx13C4pZF
nHfV5SpL3xTwn08J0GnxkIG/muvLdBWrZ6txHJk5Da0e5dMt63gULUJDfPQp
qzhdL4ljm1eiDUDo5mZZWQRD/birHkevV3E0iSYF5I/D7HVaef6JmH8WmfBT
oL24aoZ0sXBz+pAWcF3mehYm6oe//m9jEqYuw/UgnMzn6WRuJvNVrNUZ8f5i
lUwLqPwHDMxZ5/bt/sGRt4bLNElIKvMs/Ou/aXV0xwf2B50twmRdQmkYjO51
qhmM72fzztRO0Z3qACKeZ9F4lTPHF9Cfhhn1TNT9FOMV/Pwiid7ozET5X/9n
ru5nmoRUXf3jhbwOzSSKvDahrrVxC3iWmnxGeFAHB73bt3vF2qWxt/LB3YPD
o+blWYJ8dfuoc3vQ7wz6dzt3Do4G/XLlk3Ccfp//EnUJtCCIkhmWkhNs0FHP
H5weHB4OCD96Ai0XfMHP7vYHd4YqCpOQH/KzO0e9/lAt0ygRIW145FRKJ82i
awxPai/MrrHWeZ4vzXB/3xGgm+h8P8zyaBJrs/9H0snouC99rJpzCuo//vlf
1E/8F8EuegrNnH5S/LON2/DzKxynlFN7va87vUGHsccTkl46OO0+Pz/tvIXJ
GPQ6g16/1x/0b1OL89s/DX14v7WzXTgUkz7O9WSepHF6vaZV/Ks6P318YjU3
lvLT40dqh4bZVWapJ9EsmnCvjdV1ZAUXl0/5o9FZpA0o6RZPb/Yvzk/VYHB4
8PWQ1nGnuix8vHx0cXq+hShRPl+NIbj7+eTgaH+ZpcvUhHHHkFxrMp55CZdd
7CXeKO8NltYZ3BlszkAT3NzcdPVkEXaYUxLuE8bgyP0ltKqs2+zPInADD3V5
1Tl5fvpw343b/sOgd5BN6X+ocGqNB2d6ohdjndGf/aOjo+5yOvOB9ND9iGzz
KrzW6tLHdJsYhlwJqPxiHtL3ET7LLNtocU6rIUp7q/EwDlg6/UEQJHVZuzM4
sn8eDg5uD1U4Tmby+e7g8Gio4JwEQafToTfQbJM8CAo5mOpZlGijQmgQmCGz
TvLwLbNSNCU/IZqt8fhNGK+0CW6IqlFCrX/dXyBvaQVHoytzE1n1n4Jgb49Q
YYqXKsLUN2n2msyQIh65zkiWFeFPzUODTmpNqm6sSdEtxVbqaRCihcUUvT2D
O7a3p3Zu5hFpvkTrqSHfiHqpWfRWT8kLSpNdH45Tp5lpaUFQhWgZTV4btVqq
fK5JDy1XcZiVeqMiVEyaaVDKOANOq3hDqMPCCloJnpn6glpCy0VCv4yarLIM
85IDmpNRjSxOQKkbUsglYGae3oAUN/MwLxYZ0CInKRkFTd5DcGp9O4aDfEki
GenqBJiYRhlRiZBBnbEykU8y0SSVcF/Wao8cAZ3lAR6pOY24pwjRNzqO8XsH
YKNjHi00wUAEwadFmhGW2HQAxnlKLyNDUAHSKeFqqqe7bs5pZEjlTebfRzqf
QVIVzAlaEmEdoyyi6TQm6/kFCJyl09WEZea3pNK7dxWr8uHD7003gIPuIo1T
NV4TjFaAP3zoevIaiVBA5yVTUBNzEsXicAIDn7cVcbU8FdKkNzqbrWJyRhbL
MGH9RKLBEz4TIytTwe7SVOrnl8IGNOiMoEtII1N7MuVMhRvwBeM807Eo2Hm0
FNBzoiWtRsG5JWHNiLEImelMuOYmtaqFtAh5j8QLMx4/7xZw0CiMY3J1Q0gm
sEm/yLDGqSWl0z9BoV2UQ0uo/rLSxMZWgeXANng/jA2rgpUhdNFSiFVitVjF
ebT0RjbdVwHx3BfqSsPTZ/MKntPqtV5DQRHVWo9fXF612vJbPXnKfz8///sX
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

-->

</rfc>

