<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.15 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title>JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft.</spanx></t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>JSONPath was introduced by Stefan Goessner as a simple
form of XPath for JSON.
See his original article <xref target="Goessner"/>.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

</section>
<section anchor="abnf-syntax" title="ABNF Syntax">

<t>The syntax in this document conforms to ABNF as defined by <xref target="RFC5234"/>.</t>

<t>ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

</section>
</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>This memo includes no request to IANA.</t>

<t>All drafts are required to have an IANA considerations section (see
<xref format="default" target="RFC5226">Guidelines for Writing an IANA Considerations Section in
RFCs</xref> for a guide).
If the draft does not require IANA to do
anything, the section contains an explicit statement that this is the
case (as above).
If there are no requirements for IANA, the section will
be removed during conversion into an RFC by the RFC Editor.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>
<section anchor="Alternatives" title="Alternatives">

<t>An analogous standard, JSON Pointer, is provided by <xref target="RFC6901"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC5226" target='https://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>


<reference anchor="Goessner" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath - XPath for JSON</title>
    <author >
      <organization>Stefan GÃ¶ssner</organization>
    </author>
    <date year="2007" month="February"/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
1/2crUSB/z0Ho8D/2gD3c8X/Aln6UXNGSAAA

-->

</rfc>

