<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.17 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2020"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft</spanx> (which needs to be fixed soon).</t>


    </note>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a more normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues can be directed at the github repository <spanx style="emph">insert
repo here</spanx> as well as (for the time when the more permanent home is
being decided) at the dispatch@ietf.org mailing list.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a more normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers such as arrays and maps (JSON objects), and
of atomic data such as null, true, false, numbers, and text strings.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of plenty tools to analyse, transform and selectively extract data out of XML documents. <xref target="XPath"/> is one of these powerful tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the data in the server response,
minimizing bandwidth usage.</t>
</list></t>

<t>So how does such a tool look like when done for JSON?
When defining a JSONPath, how should expressions look like?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is usually anonymous and doesn't necessarily
have a "root member object", JSONPath used the abstract name <spanx style="verb">$</spanx> to
refer to the top level object of the data item.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.  Where a JSONPath processor
uses JSONPath expressions for internal purposes or as output paths,
these will always be converted to the more general <spanx style="emph">bracket–notation</spanx>.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath can employ an <spanx style="emph">underlying scripting language</spanx>, expressions of
which, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, can be used as an
alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current object.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with its XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root object/element</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current object/element</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants. JSONPath borrows this syntax from E4X.</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard. All objects/elements regardless of their names.</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access. JSON data items don't have attributes.</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator. XPath uses it to iterate over element collections and for predicates. In JavaScript and JSON it is the native array operator.</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath results in a combination of node sets. JSONPath allows alternate names or array indices as a set.</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4.</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression.</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>script expression, using the underlying script engine.</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">object</spanx> or <spanx style="emph">array</spanx> addressed by the previous path fragment. Indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [ 
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> presume an underlying script language
that allows obtaining the number of items in an array, testing for the
presence of a map member, and performing numeric comparisons of map
member values with a constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle.</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the price of everything in the store.</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1:]</spanx></c>
      <c>the last book in order.</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheapier than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all Elements in XML document. All members of JSON data item.</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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

-->

</rfc>

