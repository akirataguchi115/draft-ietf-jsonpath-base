<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.18 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2020"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="">


<t><spanx style="strong">This document is a work in progress and has not yet been published
as an Internet Draft</spanx> (which needs to be fixed soon).</t>


    </note>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues can be directed at the github repository <spanx style="emph">insert
repo here</spanx> as well as (for the time when the more permanent home is
being decided) at the dispatch@ietf.org mailing list.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.  The purposes of the two syntaxes
are different. Pointer is for isolating a single location within a
document. Path is a query syntax that can also be used to pull multiple locations.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers such as arrays and maps (JSON objects), and
of atomic data such as null, true, false, numbers, and text strings.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of
powerful tools to analyse, transform and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</t>
</list></t>

<t>So what does such a tool look like for JSON?
When defining a JSONPath, how should expressions look?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is usually anonymous and doesn't necessarily
have a "root member object", JSONPath used the abstract name <spanx style="verb">$</spanx> to
refer to the top level object of the data item.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.
[1]
Where a JSONPath processor uses JSONPath expressions as output paths,
these will always be converted to the more general <spanx style="emph">bracket–notation</spanx>.
[2]
Bracket notation is more general than dot notation and can serve as a
canonical form when a JSONPath processor uses JSONPath expressions as
output paths.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath was originally designed to employ an <spanx style="emph">underlying scripting
language</spanx> for computing expressions.  The present specification
defines a simple expression language that is independent from any
scripting language in use on the platform.</t>

<t>JSONPath can use expressions, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, as
an alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current object.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root object/element</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current object/element</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants (JSONPath borrows this syntax from E4X)</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard: All objects/elements regardless of their names</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access: JSON data items do not have attributes</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator: XPath uses it to iterate over element collections and for predicates; native array indexing as in JavaScript here</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath (results in a combination of node sets); JSONPath allows alternate names or array indices as a set</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>expression engine</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">object</spanx> or <spanx style="emph">array</spanx>
addressed by the previous path fragment. Array indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [ 
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> use the expression mechanism to obtain
the number of items in an array, to test for the presence of a map
member, and to perform numeric comparisons of map member values with a
constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the prices of everything in the store</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1]</spanx></c>
      <c>the last book in order</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheaper than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all elements in XML document; all members of JSON data item</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
H4sIAAcWzl8AA+1963LbSJbmfzxFDqs7LKlIiqQk22JZVSXrUlavb2PJWzXj
djRBMimiDQJsJGhZZXti3mH2/+6PjX2EfYDpN5kn2fOdkwkkQNBl99RMRUws
w2EKQF5Onvs5eRLsdDqBycNk+qcwThM9VHm20kG0zPgvkw96vcPeIJimkyRc
0ONpFs7yTpJmiyi5ztOk82eTJsswn3fiMNcmDyZhPlQmnwbp2KSxpntDdedO
sFpOQ/f3JE2MTswKV5juTmBW40VkTJQm+e2SZrk4uzoP4jC5HiqdBMtoGCiV
p5OiPV9N9TKf0619XJvbRaZnxmth0iyv3Zqki4VOcmNXmUd5TJP9IXwbXk6y
aJmrZ+M/60munqZ5mBMwausPl8+ebqvntL4gHI8z/Zaa0y25kelwqI5fXAU3
1+Vt9eMPwZsbuQ6w5qEa9Aa9IAhX+TzNhkFHZSmm1dMoTzOCKkoIoB+6NKtD
Kt0UbP8Q3ybV+2lGc/33Jzc0eVtdJJMuVkrr1DmjltYY5bdD9WOUTOZEDo0J
Mn1Ni3HP06ku/lwleUatX/43ulrOmf78RC/CKB6qa5q+W9L6+2vc7hIWNyzi
rKsuV1n6toD/bEqAToubDPzVXF+mq1g9X43jyMxpaPU4n25Yx+NoERrio89Z
xcntkji2eSXaAIRubpaVRTDUT7rqSfRmFUeTaFJA/iTM3qSV+5+J+eeRCT8H
2ourZkgXCzenD2kB12WuZ2Gifvjr/zUmYeoyXOfhZD5PJ3Mzma9irU6J9xer
ZFpA5d9gYE47+/v9vUNvDZdpkpBU5ln41/+p1eFdH9gfdLYIk9sSSsNgdK9T
zWB8P5t3pnaK7lQHEPE8i8arnDm+gP4kzKhnoh6mGK/g55dJ9FZnJsr/+r9z
9TDTJKTq6h8v5HFoJlHktQl1rY1bwPPU5DPCg9rb6+3v94q1S2Nv5YP7eweH
zcuzBPl6/7CzP+h3Bv37nbt7h4N+ufJJOE6/z3+OugRaEETJDEvJCTboqBfn
J3sHBwPCj55AywVf8b37/cHdoYrCJOSbfO/uYa8/VMs0SkRIG245ldJJs+ga
w5PaC7NrrHWe50sz3N11BOgmOt8NszyaxNrs/oF0MjruSh+r5pyC+rd//hf1
E/9FsIueQjOnnxR/NnEbPr/AcUo5tde71+kNOow9npD00t5J98XZSecdTMag
1xn0+r3+oL9PLc72fxr68H5rZ7twKCZ9nOvJPEnj9PqWVvE/1NnJk2OrubGU
n548Vls0zLYySz2JZtGEe62triMruLh8xpdGZ5E2oKRbPD3ZvTg7UYPBwd69
Ia3jbnVZuLx8fHFytoEoUT5fjSG4u/lk73B3maXL1IRxx5BcazKeeQmXXewl
nijvCZbWGdwdrM9AE9zc3HT1ZBF2mFMS7hPG4MjdJbSqrNvsziJwAw91edU5
fnHyaNeN2/79oLeXTel/qHBqjRuneqIXY53Rn/3Dw8PucjrzgfTQ/Zhs8yq8
1urSx3SbGIZcCaj8Yh7S9xGuZZZNtDij1RClvdV4GAcsnf4gCJK6rN0dHNo/
DwZ7+0MVjpOZXN8fHBwOFZyTIOh0OvQEmm2SB0EhB1M9ixJtVAgNAjNkbpM8
fMesFE3JT4hmt7j9NoxX2gQ3RNUooda/7C+Qt7SCo9GVuYms+k9BsLNDqDDF
QxVh6ps0e0NmSBGPXGcky4rwp+ahQSd1S6purEnRLcVW6mkQooXFFD09hTu2
s6O2buYRab5E66kh34h6qVn0Tk/JC0qTbR+OE6eZaWlBUIVoGU3eGLVaqnyu
SQ8tV3GYlXqjIlRMmmlQyjgDTqt4S6jDwgpaCZ6Z+oJaQstFQl9GTVZZhnnJ
Ac3JqEYWJ6DUDSnkEjAzT29Aipt5mBeLDGiRk5SMgibvITixvh3DQb4kkYx0
dQJMTKOMqETIoM5YmcgnmWiSSrgvt2qHHAGd5QFuqTmNuKMI0Tc6jvG9BbDR
MY8WmmAgguBqkWaEJTYdgHGe0sPIEFSAdEq4murptptzGhlSeZP595HOZ5BU
BXOClkRYxyiLaDqNyXp+BQJn6XQ1YZn5Nan0/n3Fqnz8+FvTDeCgu0jjVI1v
CUYrwB8/dj15jUQooPOSKaiJOYlicTiBgc/birha7gpp0hudzVYxOSOLZZiw
fiLR4Amfi5GVqWB3aSr1x1fCBjTojKBLSCNTezLlTIUb8AXjPNOxKNh5tBTQ
c6IlrUbBuSVhzYixCJnpTLjmJrWqhbQIeY/ECzMeP+8WcNAojGNydUNIJrBJ
X2RY49SS0umfoNAuyqElVH9ZaWJjq8ByYBu8H8aGVcHKELpoKcQqsVqs4jxa
eiOb7uuAeO4rdaXh6bN5Bc9p9UbfQkER1VpPXl5etdryrZ4+479fnP39y4sX
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

-->

</rfc>

