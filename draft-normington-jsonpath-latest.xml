<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.17 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-normington-jsonpath-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2020"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues may be directed to this document's
<eref target="https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath">github repository</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.  The purposes of the two syntaxes
are different. Pointer is for isolating a single location within a
document. Path is a query syntax that can also be used to pull multiple locations.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers such as arrays and maps (JSON objects), and
of atomic data such as null, true, false, numbers, and text strings.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of
powerful tools to analyse, transform and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</t>
</list></t>

<t>So what does such a tool look like for JSON?
When defining a JSONPath, how should expressions look?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is usually anonymous and doesn't necessarily
have a "root member object", JSONPath used the abstract name <spanx style="verb">$</spanx> to
refer to the top level object of the data item.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.
[1]
Where a JSONPath processor uses JSONPath expressions as output paths,
these will always be converted to the more general <spanx style="emph">bracket–notation</spanx>.
[2]
Bracket notation is more general than dot notation and can serve as a
canonical form when a JSONPath processor uses JSONPath expressions as
output paths.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath was originally designed to employ an <spanx style="emph">underlying scripting
language</spanx> for computing expressions.  The present specification
defines a simple expression language that is independent from any
scripting language in use on the platform.</t>

<t>JSONPath can use expressions, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, as
an alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current object.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root object/element</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current object/element</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants (JSONPath borrows this syntax from E4X)</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard: All objects/elements regardless of their names</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access: JSON data items do not have attributes</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator: XPath uses it to iterate over element collections and for predicates; native array indexing as in JavaScript here</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath (results in a combination of node sets); JSONPath allows alternate names or array indices as a set</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>expression engine</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">object</spanx> or <spanx style="emph">array</spanx>
addressed by the previous path fragment. Array indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> use the expression mechanism to obtain
the number of items in an array, to test for the presence of a map
member, and to perform numeric comparisons of map member values with a
constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the prices of everything in the store</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1]</spanx></c>
      <c>the last book in order</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheaper than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all elements in XML document; all members of JSON data item</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
9Zx+8Yt49ucRqIrj/wGomPbjwnQAAA==

-->

</rfc>

