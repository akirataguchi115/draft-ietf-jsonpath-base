<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.17 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="true"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="true"?>
<?rfc sortrefs="true"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-jsonpath-base-latest" category="std" consensus="true" submissionType="IETF" xml:lang="en" obsoletes="" updates="">

  <front>
    <title abbrev="JSONPath">JavaScript Object Notation (JSON) Path</title>

    <author initials="G." surname="Normington" fullname="Glyn Normington" role="editor">
      <organization>VMware, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Winchester</city>
          <region></region>
          <code></code>
          <country>UK</country>
        </postal>
        <phone></phone>
        <email>glyn.normington@gmail.com</email>
      </address>
    </author>
    <author initials="E." surname="Surov" fullname="Edward Surov" role="editor">
      <organization>TheSoul Publishing Ltd.</organization>
      <address>
        <postal>
          <street></street>
          <city>Limassol</city>
          <region></region>
          <code></code>
          <country>Cyprus</country>
        </postal>
        <phone></phone>
        <email>esurov.tsp@gmail.com</email>
      </address>
    </author>
    <author initials="M." surname="Mikulicic" fullname="Marko Mikulicic" role="editor">
      <organization>InfluxData, Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Pisa</city>
          <region></region>
          <code></code>
          <country>IT</country>
        </postal>
        <phone></phone>
        <email>mmikulicic@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
      <address>
        <postal>
          <street>Sonnenstraße 96</street>
          <city>Dortmund</city>
          <code>D-44139</code>
          <country>Germany</country>
        </postal>
        <email>stefan.goessner@fh-dortmund.de</email>
      </address>
    </author>

    <date year="2021"/>

    <area>ART</area>
    <workgroup>JSONPath WG</workgroup>
    <keyword>JSON</keyword>

    <abstract>


<t>JSONPath defines a string syntax for identifying values
within a JavaScript Object Notation (JSON) document.</t>



    </abstract>


    <note title="Contributing">


<t>This document picks up the popular JSONPath specification dated
2007-02-21 and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>Comments and issues may be directed to this document's
<eref target="https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath">github repository</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document picks up the popular JSONPath specification dated
2007-02-21 <xref target="JSONPath-orig"/> and provides a normative definition for it.
In its current state, it is a strawman document showing what needs to
be covered.</t>

<t>JSON is defined by <xref target="RFC8259"/>.</t>

<t>JSONPath is not intended as a replacement, but as a more powerful
companion, to JSON Pointer <xref target="RFC6901"/>. [insert reference to section
where the relationship is detailed.  The purposes of the two syntaxes
are different. Pointer is for isolating a single location within a
document. Path is a query syntax that can also be used to pull multiple locations.]</t>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>The grammatical rules in this document are to be interpreted as ABNF,
as described in <xref target="RFC5234"/>.
ABNF terminal values in this document define Unicode code points rather than
their UTF-8 encoding.
For example, the Unicode PLACE OF INTEREST SIGN (U+2318) would be defined
in ABNF as <spanx style="verb">%x2318</spanx>.</t>

<t>The terminology of <xref target="RFC8259"/> applies.</t>

<t><list style="hanging">
  <t hangText="Data Item:">
  A structure complying to the generic data model of JSON, i.e.,
composed of containers such as arrays and maps (JSON objects), and
of atomic data such as null, true, false, numbers, and text strings.</t>
  <t hangText="Object:">
  Used in its generic sense, e.g., for programming language objects.
When a JSON Object as defined in <xref target="RFC8259"/> is meant, we specifically
say JSON Object.</t>
  <t hangText="Query:">
  Short name for JSONPath expression.</t>
  <t hangText="Argument:">
  Short name for the JSON data item a JSONPath expression is applied to.</t>
  <t hangText="Output Path:">
  A simple form of JSONPath expression that identifies a Position by
providing a query that results in exactly that position.  Similar
to, but syntactically different from, a JSON Pointer <xref target="RFC6901"/>.</t>
  <t hangText="Position:">
  A JSON data item identical to or nested within the JSON data item to
which the query is applied to, expressed either by the value of that
data item or by providing a JSONPath Output Path.</t>
</list></t>

</section>
<section anchor="inspired-by-xpath" title="Inspired by XPath">

<t>A frequently emphasized advantage of XML is the availability of
powerful tools to analyse, transform and selectively extract data from
XML documents.
<xref target="XPath"/> is one of these tools.</t>

<t>In 2007, the need for something solving the same class of problems for
the emerging JSON community became apparent, specifically for:</t>

<t><list style="symbols">
  <t>Finding data interactively and extracting them out of <xref target="RFC8259"/>
data items without special scripting.</t>
  <t>Specifying the relevant parts of the JSON data in a request by a
client, so the server can reduce the amount of data in its response,
minimizing bandwidth usage.</t>
</list></t>

<t>So what does such a tool look like for JSON?
When defining a JSONPath, how should expressions look?</t>

<t>The XPath expression</t>

<figure><artwork><![CDATA[
/store/book[1]/title
]]></artwork></figure>

<t>looks like</t>

<figure><artwork><![CDATA[
x.store.book[0].title
]]></artwork></figure>

<t>or</t>

<figure><artwork><![CDATA[
x['store']['book'][0]['title']
]]></artwork></figure>

<t>in popular programming languages such as JavaScript, Python and PHP,
with a variable x holding the JSON data item.  Here we observe that
such languages already have a fundamentally XPath-like feature built
in.</t>

<t>The JSONPath tool in question should:</t>

<t><list style="symbols">
  <t>be naturally based on those language characteristics.</t>
  <t>cover only essential parts of XPath 1.0.</t>
  <t>be lightweight in code size and memory consumption.</t>
  <t>be runtime efficient.</t>
</list></t>

</section>
<section anchor="overview-of-jsonpath-expressions" title="Overview of JSONPath Expressions">

<t>JSONPath expressions always apply to a JSON data item in the same way
as XPath expressions are used in combination with an XML document.
Since a JSON data item is usually anonymous and doesn't necessarily
have a "root member object", JSONPath used the abstract name <spanx style="verb">$</spanx> to
refer to the top level object of the data item.</t>

<t>JSONPath expressions can use the <spanx style="emph">dot–notation</spanx></t>

<figure><artwork><![CDATA[
$.store.book[0].title
]]></artwork></figure>

<t>or the <spanx style="emph">bracket–notation</spanx></t>

<figure><artwork><![CDATA[
$['store']['book'][0]['title']
]]></artwork></figure>

<t>for paths input to a JSONPath processor.
[1]
Where a JSONPath processor uses JSONPath expressions as output paths,
these will always be converted to the more general <spanx style="emph">bracket–notation</spanx>.
[2]
Bracket notation is more general than dot notation and can serve as a
canonical form when a JSONPath processor uses JSONPath expressions as
output paths.</t>

<t>JSONPath allows the wildcard symbol <spanx style="verb">*</spanx> for member names and array
indices. It borrows the descendant operator <spanx style="verb">..</spanx> from <xref target="E4X"/> and
the array slice syntax proposal <spanx style="verb">[start:end:step]</spanx> <xref target="SLICE"/> from ECMASCRIPT 4.</t>

<t>JSONPath was originally designed to employ an <spanx style="emph">underlying scripting
language</spanx> for computing expressions.  The present specification
defines a simple expression language that is independent from any
scripting language in use on the platform.</t>

<t>JSONPath can use expressions, written in parentheses: <spanx style="verb">(&lt;expr&gt;)</spanx>, as
an alternative to explicit names or indices as in:</t>

<figure><artwork><![CDATA[
$.store.book[(@.length-1)].title
]]></artwork></figure>

<t>The symbol <spanx style="verb">@</spanx> is used for the current object.
Filter expressions are supported via the syntax <spanx style="verb">?(&lt;boolean expr&gt;)</spanx> as in</t>

<figure><artwork><![CDATA[
$.store.book[?(@.price < 10)].title
]]></artwork></figure>

<t>Here is a complete overview and a side by side comparison of the JSONPath syntax elements with their XPath counterparts.</t>

<texttable title="Overview over JSONPath, comparing to XPath" anchor="tbl-overview">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">$</spanx></c>
      <c>the root object/element</c>
      <c><spanx style="verb">.</spanx></c>
      <c><spanx style="verb">@</spanx></c>
      <c>the current object/element</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">.</spanx> or <spanx style="verb">[]</spanx></c>
      <c>child operator</c>
      <c><spanx style="verb">..</spanx></c>
      <c>n/a</c>
      <c>parent operator</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">..</spanx></c>
      <c>nested descendants (JSONPath borrows this syntax from E4X)</c>
      <c><spanx style="verb">*</spanx></c>
      <c><spanx style="verb">*</spanx></c>
      <c>wildcard: All objects/elements regardless of their names</c>
      <c><spanx style="verb">@</spanx></c>
      <c>n/a</c>
      <c>attribute access: JSON data items do not have attributes</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">[]</spanx></c>
      <c>subscript operator: XPath uses it to iterate over element collections and for predicates; native array indexing as in JavaScript here</c>
      <c><spanx style="verb">¦</spanx></c>
      <c><spanx style="verb">[,]</spanx></c>
      <c>Union operator in XPath (results in a combination of node sets); JSONPath allows alternate names or array indices as a set</c>
      <c>n/a</c>
      <c><spanx style="verb">[start:end:step]</spanx></c>
      <c>array slice operator borrowed from ES4</c>
      <c><spanx style="verb">[]</spanx></c>
      <c><spanx style="verb">?()</spanx></c>
      <c>applies a filter (script) expression</c>
      <c>n/a</c>
      <c><spanx style="verb">()</spanx></c>
      <c>expression engine</c>
      <c><spanx style="verb">()</spanx></c>
      <c>n/a</c>
      <c>grouping in Xpath</c>
</texttable>

<!-- note that the weirdness about the vertical bar above is intentional -->

<t>XPath has a lot more to offer (location paths in unabbreviated syntax,
operators and functions) than listed here.  Moreover there is a
significant difference how the subscript operator works in Xpath and
JSONPath:</t>

<t><list style="symbols">
  <t>Square brackets in XPath expressions always operate on the <spanx style="emph">node set</spanx> resulting from the previous path fragment. Indices always start at 1.</t>
  <t>With JSONPath, square brackets operate on the <spanx style="emph">object</spanx> or <spanx style="emph">array</spanx>
addressed by the previous path fragment. Array indices always start at 0.</t>
</list></t>

</section>
</section>
<section anchor="jsonpath-examples" title="JSONPath Examples">

<t>This section provides some more examples for JSONPath expressions.
The examples are based on a simple JSON data item patterned after a
typical XML example representing a bookstore (that also has bicycles):</t>

<figure title="Example JSON data item"><artwork type="json"><![CDATA[
{ "store": {
    "book": [
      { "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      { "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      { "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      { "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 19.95
    }
  }
}
]]></artwork></figure>

<t>The examples in <xref target="tbl-example"/> use the expression mechanism to obtain
the number of items in an array, to test for the presence of a map
member, and to perform numeric comparisons of map member values with a
constant.</t>

<texttable title="Example JSONPath expressions applied to the example JSON data item" anchor="tbl-example">
      <ttcol align='left'>XPath</ttcol>
      <ttcol align='left'>JSONPath</ttcol>
      <ttcol align='left'>Result</ttcol>
      <c><spanx style="verb">/store/book/author</spanx></c>
      <c><spanx style="verb">$.store.book[*].author</spanx></c>
      <c>the authors of all books in the store</c>
      <c><spanx style="verb">//author</spanx></c>
      <c><spanx style="verb">$..author</spanx></c>
      <c>all authors</c>
      <c><spanx style="verb">/store/*</spanx></c>
      <c><spanx style="verb">$.store.*</spanx></c>
      <c>all things in store, which are some books and a red bicycle</c>
      <c><spanx style="verb">/store//price</spanx></c>
      <c><spanx style="verb">$.store..price</spanx></c>
      <c>the prices of everything in the store</c>
      <c><spanx style="verb">//book[3]</spanx></c>
      <c><spanx style="verb">$..book[2]</spanx></c>
      <c>the third book</c>
      <c><spanx style="verb">//book[last()]</spanx></c>
      <c><spanx style="verb">$..book[(@.length-1)]</spanx><br /><spanx style="verb">$..book[-1]</spanx></c>
      <c>the last book in order</c>
      <c><spanx style="verb">//book[position()&lt;3]</spanx></c>
      <c><spanx style="verb">$..book[0,1]</spanx><br /><spanx style="verb">$..book[:2]</spanx></c>
      <c>the first two books</c>
      <c><spanx style="verb">//book[isbn]</spanx></c>
      <c><spanx style="verb">$..book[?(@.isbn)]</spanx></c>
      <c>filter all books with isbn number</c>
      <c><spanx style="verb">//book[price&lt;10]</spanx></c>
      <c><spanx style="verb">$..book[?(@.price&lt;10)]</spanx></c>
      <c>filter all books cheaper than 10</c>
      <c><spanx style="verb">//*</spanx></c>
      <c><spanx style="verb">$..*</spanx></c>
      <c>all elements in XML document; all members of JSON data item</c>
</texttable>

<!-- back to normington draft; not yet merged up where needed (e.g., terminology). -->

</section>
<section anchor="jsonpath-syntax-and-semantics" title="JSONPath Syntax and Semantics">

<section anchor="overview" title="Overview">

<t>A JSONPath is a string which selects zero or more nodes of a piece of JSON.
A valid JSONPath conforms to the ABNF syntax defined by this document.</t>

<t>A JSONPath MUST be encoded using UTF-8. To parse a JSONPath according to
the grammar in this document, its UTF-8 form SHOULD first be decoded into
Unicode code points as described
in <xref target="RFC3629"/>.</t>

</section>
<section anchor="terminology-1" title="Terminology">

<t>A JSON value is logically a tree of nodes.</t>

<t>Each node holds a JSON value (as defined by <xref target="RFC8259"/>) of one of the
types object, array, number, string, or one of the literals <spanx style="verb">true</spanx>,
<spanx style="verb">false</spanx>, or <spanx style="verb">null</spanx>.
The type of the JSON value held by a node is
sometimes referred to as the type of the node.</t>

</section>
<section anchor="implementation" title="Implementation">

<t>An implementation of this specification, from now on referred to simply as
"an implementation", SHOULD takes two inputs, a JSONPath and a JSON value,
and produce
a possibly empty list of nodes of the JSON value which are selected by
the JSONPath or an error (but not both).</t>

<t>If no node is selected and no error has occurred, an implementation MUST
return an empty list of nodes.</t>

<t>Syntax errors in the JSONPath SHOULD be detected before selection is attempted
since these errors do not depend on the JSON value.
Therefore, an implementation SHOULD take a JSONPath and produce an optional
syntax error and then,
if and only if an error was not produced, SHOULD take a JSON value and
produce a list of nodes or an error (but not both).</t>

<t>Alternatively, an implementation MAY take a JSONPath and a JSON value
and produce a list of nodes or an optional error (but not both).</t>

<t>For any implementation, if a syntactically invalid JSONPath is provided,
the implementation MUST return an error.</t>

<t>If a syntactially invalid JSON value is provided, any implementation SHOULD
return an error.</t>

</section>
<section anchor="syntax" title="Syntax">

<t>Syntactically, a JSONPath consists of a root selector (<spanx style="verb">$</spanx>), which
selects the root node of a JSON value, followed by a possibly empty
sequence of <spanx style="emph">selectors</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
json-path = root-selector *selector
root-selector = %x24               ; $ selects document root node
]]></artwork></figure>

<t>The syntax and semantics of each selector is defined below.</t>

</section>
<section anchor="semantics" title="Semantics">

<t>The root selector <spanx style="verb">$</spanx> not only selects the root node of the input
document, but it also produces as output a list consisting of one
node: the input document.</t>

<t>A selector may select zero or more nodes for further processing.
A syntactically valid selector MUST NOT produce errors.
This means that some
operations which might be considered erroneous, such as indexing beyond the
end of an array,
simply result in fewer nodes being selected.</t>

<t>But a selector doesn't just act on a single node: each selector acts on a
list of nodes and produces a list of nodes, as follows.</t>

<t>After the root selector, the remainder of the JSONPath is processed by passing
lists of nodes from one selector to the next ending up with a list of nodes
which is the result of
applying the JSONPath to the input JSON value.</t>

<t>Each selector acts on its input list of nodes as follows.
For each node in
the list, the selector selects zero or more nodes, each of which is a descendant
of the node or the node itself.
The output list of nodes of a selector is the concatenation of the lists
of selected nodes for each input node.</t>

<t>A specific, non-normative example will make this clearer.
Suppose the input
document is: <spanx style="verb">{"a":[{"b":0},{"b":1},{"c":2}]}</spanx>.
As we will see later, the JSONPath <spanx style="verb">$.a[*].b</spanx> selects the following list of nodes: <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
Let's walk through this in detail.</t>

<t>The JSONPath consists of <spanx style="verb">$</spanx> followed by three selectors: <spanx style="verb">.a</spanx>, <spanx style="verb">[*]</spanx>, and <spanx style="verb">.b</spanx>.</t>

<t>Firstly, <spanx style="verb">$</spanx> selects the root node which is the input document.
So the result is a list
consisting of just the root node.</t>

<t>Next, <spanx style="verb">.a</spanx> selects from any input node of type object and selects any value of the input
node corresponding to the key <spanx style="verb">"a"</spanx>.
The result is again a list of one node: <spanx style="verb">[{"b":0},{"b":1},{"c":2}]</spanx>.</t>

<t>Next, <spanx style="verb">[*]</spanx> selects from any input node which is an array and selects all the elements
of the input node.
The result is a list of three nodes: <spanx style="verb">{"b":0}</spanx>, <spanx style="verb">{"b":1}</spanx>, and <spanx style="verb">{"c":2}</spanx>.</t>

<t>Finally, <spanx style="verb">.b</spanx> selects from any input node of type object with a key
<spanx style="verb">b</spanx> and selects the value of the input node corresponding to that key.
The result is a list containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>.
This is the concatenation of three lists, two of length one containing <spanx style="verb">0</spanx>, <spanx style="verb">1</spanx>, respectively, and one of length zero.</t>

<t>As a consequence of this approach, if any of the selectors selects no nodes,
then the whole JSONPath selects no nodes.</t>

<t>In what follows, the semantics of each selector are defined for each type
of node.</t>

</section>
<section anchor="selectors" title="Selectors">

<section anchor="dot-child-selector" title="Dot Child Selector">

<section numbered="false" toc="exclude" anchor="syntax-1" title="Syntax">

<t>A dot child selector has a key known as a dot child name or a single asterisk
(<spanx style="verb">*</spanx>).</t>

<t>A dot child name corresponds to a name in a JSON object.</t>

<figure><artwork type="abnf"><![CDATA[
selector = dot-child              ; see below for alternatives
dot-child = %x2E dot-child-name / ; .<dot-child-name>
            %x2E %x2A             ; .*
dot-child-name = 1*(
                   %x2D /         ; -
                   DIGIT /
                   ALPHA /
                   %x5F /         ; _
                   %x80-10FFFF    ; any non-ASCII Unicode character
                 )
DIGIT =  %x30-39                  ; 0-9
ALPHA = %x41-5A / %x61-7A         ; A-Z / a-z
]]></artwork></figure>

<t>More general child names, such as the empty string, are supported by "Union
Child" (<xref target="unionchild" format="default"/>).</t>

<t>Note that the <spanx style="verb">dot-child-name</spanx> rule follows the philosophy of JSON strings and is
allowed to contain bit sequences that cannot encode Unicode characters (a
single unpaired UTF-16 surrogate, for example).
The behaviour of an implementation is undefined for child names which do
not encode Unicode characters.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-1" title="Semantics">

<t>A dot child name which is not a single asterisk (<spanx style="verb">*</spanx>) is considered to have a key.
It selects the value corresponding to the key from any object node.
It selects
no nodes from a node which is not an object.</t>

<t>The key of a dot child name is the sequence of Unicode characters contained
in that name.</t>

<t>A dot child name consisting of a single asterisk is a wild card. It selects
all the values of any object node.
It also selects all the elements of any array node.
It selects no nodes from
number, string, or literal nodes.</t>

</section>
</section>
<section anchor="union-selector" title="Union Selector">

<section anchor="syntax-2" title="Syntax">

<t>A union selector consists of one or more union elements.</t>

<figure><artwork type="abnf"><![CDATA[
selector =/ union
union = %x5B ws union-elements ws %x5D ; [...]
ws = *%x20                             ; zero or more spaces
union-elements = union-element /
                 union-element ws %x2C ws union-elements
                                       ; ,-separated list
]]></artwork></figure>

</section>
<section anchor="semantics-2" title="Semantics">

<t>A union selects any node which is selected by at least one of the union selectors
and selects the concatenation of the
lists (in the order of the selectors) of nodes selected by the union elements.<!--  TODO: define whether duplicates are kept or removed.  --></t>

</section>
<section anchor="unionchild" title="Child">

<section numbered="false" toc="exclude" anchor="syntax-3" title="Syntax">

<t>A child is a quoted string.</t>

<figure><artwork type="abnf"><![CDATA[
union-element = child ; see below for more alternatives
child = %x22 *double-quoted %x22 / ; "string"
        %x27 *single-quoted %x27   ; 'string'

double-quoted = dq-unescaped /
          escape (
              %x22 /          ; "    quotation mark  U+0022
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX


      dq-unescaped = %x20-21 / %x23-5B / %x5D-10FFFF

single-quoted = sq-unescaped /
          escape (
              %x27 /          ; '    apostrophe      U+0027
              %x2F /          ; /    solidus         U+002F
              %x5C /          ; \    reverse solidus U+005C
              %x62 /          ; b    backspace       U+0008
              %x66 /          ; f    form feed       U+000C
              %x6E /          ; n    line feed       U+000A
              %x72 /          ; r    carriage return U+000D
              %x74 /          ; t    tab             U+0009
              %x75 4HEXDIG )  ; uXXXX                U+XXXX

      sq-unescaped = %x20-26 / %x28-5B / %x5D-10FFFF

escape = %x5C                 ; \

HEXDIG =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                              ; case insensitive hex digit
]]></artwork></figure>

<t>Notes:
1. double-quoted strings follow JSON in <xref target="RFC8259"/>.
   Single-quoted strings follow an analogous pattern.
2. <spanx style="verb">HEXDIG</spanx> includes A-F and a-f.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-3" title="Semantics">

<t>If the child is a quoted string, the string MUST be converted to a
key by removing the surrounding quotes and
replacing each escape sequence with its equivalent Unicode character, as
in the table below:</t>

<texttable title="Escape Sequence Replacements">
      <ttcol align='center'>Escape Sequence</ttcol>
      <ttcol align='center'>Unicode Character</ttcol>
      <c>%x5C %x22</c>
      <c>U+0022</c>
      <c>%x5C %x27</c>
      <c>U+0027</c>
      <c>%x5C %x2F</c>
      <c>U+002F</c>
      <c>%x5C %x5C</c>
      <c>U+005C</c>
      <c>%x5C %x62</c>
      <c>U+0008</c>
      <c>%x5C %x66</c>
      <c>U+000C</c>
      <c>%x5C %x6E</c>
      <c>U+000A</c>
      <c>%x5C %x72</c>
      <c>U+000D</c>
      <c>%x5C %x74</c>
      <c>U+0009</c>
      <c>%x5C uXXXX</c>
      <c>U+XXXX</c>
</texttable>

<t>The child selects the value corresponding to the key from any object
node with the key as a name.
It selects no nodes from a node which is not an object.</t>

</section>
</section>
<section anchor="array-selector" title="Array Selector">

<section numbered="false" toc="exclude" anchor="syntax-4" title="Syntax">

<t>An array selector selects zero or more elements of an array node.
An array selector takes the form of an index, which selects at most one element,
or a slice, which selects zero or more elements.</t>

<figure><artwork type="abnf"><![CDATA[
union-element =/ array-index / array-slice
]]></artwork></figure>

<t>An array index is an integer (in base 10).</t>

<figure><artwork type="abnf"><![CDATA[
array-index = integer

integer = ["-"] ("0" / (DIGIT1 *DIGIT))
                            ; optional - followed by 0 or
                            ; sequence of digits with no leading zero
DIGIT1 = %x31-39            ; non-zero digit
]]></artwork></figure>

<t>Note: the syntax does not allow integers with leading zeros such as <spanx style="verb">01</spanx> and <spanx style="verb">-01</spanx>.</t>

<t>An array slice consists of three optional integers (in base 10) separated by colons.</t>

<figure><artwork type="abnf"><![CDATA[
array-slice = [ start ] ws ":" ws [ end ]
                   [ ws ":" ws [ step ] ]
start = integer
end = integer
step = integer
]]></artwork></figure>

<t>Note: the array slices <spanx style="verb">:</spanx> and <spanx style="verb">::</spanx> are both syntactically valid, as are <spanx style="verb">:2:2</spanx>, <spanx style="verb">2::2</spanx>, and <spanx style="verb">2:4:</spanx>.</t>

</section>
<section numbered="false" toc="exclude" anchor="semantics-4" title="Semantics">

<section numbered="false" toc="exclude" anchor="informal-introduction" title="Informal Introduction">

<t>This section is non-normative.</t>

<t>Array indexing is a way of selecting a particular element of an array using
a 0-based index.
For example, the expression <spanx style="verb">[0]</spanx> selects the first element of a non-empty array.</t>

<t>Negative indices index from the end of an array.
For example, the expression <spanx style="verb">[-2]</spanx> selects the last but one element of an array with at least two elements.</t>

<t>Array slicing is inspired by the behaviour of the <spanx style="verb">Array.prototype.slice</spanx> method
of the JavaScript language as defined by the ECMA-262 standard <xref target="ECMA-262"/>,
with the addition of the <spanx style="verb">step</spanx> parameter, which is inspired by the Python slice expression.</t>

<t>The array slice expression <spanx style="verb">[start:end:step]</spanx> selects elements at indices starting at <spanx style="verb">start</spanx>,
incrementing by <spanx style="verb">step</spanx>, and ending with <spanx style="verb">end</spanx> (which is itself excluded).
So, for example, the expression <spanx style="verb">[1:3]</spanx> (where <spanx style="verb">step</spanx> defaults to <spanx style="verb">1</spanx>)
selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">2</spanx> (in that order) whereas
<spanx style="verb">[1:5:2]</spanx> selects elements with indices <spanx style="verb">1</spanx> and <spanx style="verb">3</spanx>.</t>

<t>When <spanx style="verb">step</spanx> is negative, elements are selected in reverse order. Thus,
for example, <spanx style="verb">[5:1:-2]</spanx> selects elements with indices <spanx style="verb">5</spanx> and <spanx style="verb">3</spanx>, in
that order and <spanx style="verb">[::-1]</spanx> selects all the elements of an array in
reverse order.</t>

<t>When <spanx style="verb">step</spanx> is <spanx style="verb">0</spanx>, no elements are selected.
This is the one case which differs from the behaviour of Python, which
raises an error in this case.</t>

<t>The following section specifies the behaviour fully, without depending on
JavaScript or Python behaviour.</t>

</section>
<section numbered="false" toc="exclude" anchor="detailed-semantics" title="Detailed Semantics">

<t>An array selector is either an array slice or an array index, which is defined
in terms of an array slice.</t>

<t>A slice expression selects a subset of the elements of the input array, in
the same order
as the array or the reverse order, depending on the sign of the <spanx style="verb">step</spanx> parameter.
It selects no nodes from a node which is not an array.</t>

<t>A slice is defined by the two slice parameters, <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>, and
an iteration delta, <spanx style="verb">step</spanx>.
Each of these parameters is
optional. <spanx style="verb">len</spanx> is the length of the input array.</t>

<t>The default value for <spanx style="verb">step</spanx> is <spanx style="verb">1</spanx>.
The default values for <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> depend on the sign of <spanx style="verb">step</spanx>,
as follows:</t>

<texttable title="Default array slice start and end values">
      <ttcol align='left'>Condition</ttcol>
      <ttcol align='left'>start</ttcol>
      <ttcol align='left'>end</ttcol>
      <c>step &gt;= 0</c>
      <c>0</c>
      <c>len</c>
      <c>step &lt; 0</c>
      <c>len - 1</c>
      <c>-len - 1</c>
</texttable>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are not directly usable
as slice bounds and must first be normalized. Normalization is defined as:</t>

<figure><artwork><![CDATA[
FUNCTION Normalize(i):
  IF i >= 0 THEN
    RETURN i
  ELSE
    RETURN len + i
  END IF
]]></artwork></figure>

<t>The result of the array indexing expression <spanx style="verb">[i]</spanx> is defined to be the result of the array
slicing expression <spanx style="verb">[i:Normalize(i)+1:1]</spanx>.</t>

<t>Slice expression parameters <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> are used to derive slice bounds <spanx style="verb">lower</spanx> and <spanx style="verb">upper</spanx>.
The direction of the iteration, defined
by the sign of <spanx style="verb">step</spanx>, determines which of the parameters is the lower bound and which
is the upper bound:</t>

<figure><artwork><![CDATA[
FUNCTION Bounds(start, end, step, len):
  n_start = Normalize(start)
  n_end = Normalize(end)

  IF step >= 0 THEN
    lower = MIN(MAX(n_start, 0), len)
    upper = MIN(MAX(n_end, 0), len)
  ELSE
    upper = MIN(MAX(n_start, -1), len-1)
    lower = MIN(MAX(n_end, -1), len-1)
  END IF

  RETURN (lower, upper)
]]></artwork></figure>

<t>The slice expression selects elements with indices between the lower and
upper bounds.
In the following pseudocode, the <spanx style="verb">a(i)</spanx> construct expresses the
0-based indexing operation on the underlying array.</t>

<figure><artwork><![CDATA[
IF step > 0 THEN

  i = lower
  WHILE i < upper:
    SELECT a(i)
    i = i + step
  END WHILE

ELSE if step < 0 THEN

  i = upper
  WHILE lower < i:
    SELECT a(i)
    i = i + step
  END WHILE

END IF
]]></artwork></figure>

<t>When <spanx style="verb">step = 0</spanx>, no elements are selected and the result array is empty.</t>

<t>An implementation MUST raise an error if any of the slice expression parameters
does not fit in
the implementation's representation of an integer.
If a successfully parsed slice expression is evaluated against an array whose
size doesn't
fit in the implementation's representation of an integer, the implementation
MUST raise an error.</t>

</section>
</section>
</section>
</section>
</section>
</section>
<section anchor="IANA" title="IANA Considerations">

<t>TBD: Define a media type for JSON Path expressions.</t>

</section>
<section anchor="Security" title="Security Considerations">

<t>This section gives security considerations, as required by <xref target="RFC3552"/>.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC6901" target='https://www.rfc-editor.org/info/rfc6901'>
<front>
<title>JavaScript Object Notation (JSON) Pointer</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan' role='editor'><organization /></author>
<author initials='K.' surname='Zyp' fullname='K. Zyp'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<date year='2013' month='April' />
<abstract><t>JSON Pointer defines a string syntax for identifying a specific value within a JavaScript Object Notation (JSON) document.</t></abstract>
</front>
<seriesInfo name='RFC' value='6901'/>
<seriesInfo name='DOI' value='10.17487/RFC6901'/>
</reference>


<reference anchor="JSONPath-orig" target="https://goessner.net/articles/JsonPath/">
  <front>
    <title>JSONPath – XPath for JSON</title>
    <author initials="S." surname="Gössner" fullname="Stefan Gössner">
      <organization>Fachhochschule Dortmund</organization>
    </author>
    <date year="2007" month="February" day="21"/>
  </front>
</reference>




<reference anchor="XPath"
           target='https://www.w3.org/TR/2010/REC-xpath20-20101214'>
<front>
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<author initials='A.' surname='Berglund' fullname='Anders Berglund'>
    <organization />
</author>

<author initials='S.' surname='Boag' fullname='Scott Boag'>
    <organization />
</author>

<author initials='D.' surname='Chamberlin' fullname='Don Chamberlin'>
    <organization />
</author>

<author initials='M.' surname='Fernandez' fullname='Mary Fernandez'>
    <organization />
</author>

<author initials='M.' surname='Kay' fullname='Michael Kay'>
    <organization />
</author>

<author initials='J.' surname='Robie' fullname='Jonathan Robie'>
    <organization />
</author>

<author initials='J.' surname='Simeon' fullname='Jerome Simeon'>
    <organization />
</author>

<date month='December' day='14' year='2010' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xpath20-20101214' />
<format type='HTML' target='https://www.w3.org/TR/2010/REC-xpath20-20101214' />
</reference>


<reference anchor="E4X" >
  <front>
    <title>Information technology — ECMAScript for XML (E4X) specification</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="2006"/>
  </front>
  <seriesInfo name="ISO/IEC 22537:2006" value=""/>
</reference>
<reference anchor="SLICE" target="https://github.com/tc39/proposal-slice-notation">
  <front>
    <title>Slice notation</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="ECMA-262" target="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">
  <front>
    <title>ECMAScript Language Specification, Standard ECMA-262, Third Edition</title>
    <author >
      <organization>Ecma International</organization>
    </author>
    <date year="1999" month="December"/>
  </front>
</reference>


    </references>


<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>This specification is based on <contact fullname="Stefan Gössner" />'s
original online article defining JSONPath <xref target="JSONPath-orig"/>.</t>

<t>The books example was taken from
http://coli.lili.uni-bielefeld.de/~andreas/Seminare/sommer02/books.xml
— a dead link now.</t>

<!--  LocalWords:  JSONPath XPath
 -->

</section>

    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
        <name>Contributors</name>
    <contact initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization ascii="Universitaet Bremen TZI">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </contact>
    </section>

  </back>

<!-- ##markdown-source:
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
n6fjMP4Rfz1nUP4invl5BKri+H89h1Xn1HQAAA==

-->

</rfc>

